function generateLargeMosaicInSteps
    mosaicFOV = 10;
    spacing = coneSpacingDistribution(mosaicFOV);
    minPositionChangeToTriggerTriangularization = round(median(spacing)*0.5*100)/100
    visualizationUpdateIterations = 5;
    
    mosaicParams = struct(...
        'resamplingFactor', 7, ...
        'fovDegs', mosaicFOV, ...
        'LMSRatio', [0.60 0.30 0.10], ...
        'sConeMinDistanceFactor', 3, ...
        'sConeFreeRadiusMicrons', 45, ...
        'latticeAdjustmentPositionalToleranceF', minPositionChangeToTriggerTriangularization, ...
        'latticeAdjustmentDelaunayToleranceF', 1e-3, ...
        'queryGridAdjustmentIterations', 100, ...           % Pass Inf, to avoid querying
        'visualizationUpdateIterations', visualizationUpdateIterations, ...
        'maxGridAdjustmentIterations', 10000, ...
        'marginF',[]....
        );

    theMosaic = coneMosaicHex(mosaicParams.resamplingFactor, ...
        'fovDegs',                       mosaicParams.fovDegs, ...
        'spatialDensity',                [0 mosaicParams.LMSRatio]', ...
        'sConeMinDistanceFactor',        mosaicParams.sConeMinDistanceFactor, ...
        'sConeFreeRadiusMicrons',        mosaicParams.sConeFreeRadiusMicrons, ...
        'eccBasedConeDensity',           true, ...                                  % cone density varies with eccentricity
        'eccBasedConeQuantalEfficiency', true, ...                                  % cone quantal efficiency varies with eccentricity
        'latticeAdjustmentPositionalToleranceF',mosaicParams.latticeAdjustmentPositionalToleranceF, ...
        'latticeAdjustmentDelaunayToleranceF',  mosaicParams.latticeAdjustmentDelaunayToleranceF, ...
        'marginF',                              mosaicParams.marginF, ...
        'queryGridAdjustmentIterations',        mosaicParams.queryGridAdjustmentIterations, ...
        'visualizationUpdateIterations',        mosaicParams.visualizationUpdateIterations, ...
        'maxGridAdjustmentIterations',          mosaicParams.maxGridAdjustmentIterations);
    
    
    theMosaic.visualizeGrid('ticksInVisualDegs', true);
    mosaicFileName = sprintf('ConeMosaic_%2.1fDegs_PosTolerance%2.2f', mosaicFOV, mosaicParams.latticeAdjustmentPositionalToleranceF);
    
    % Print final figure
    hFig = figure(111);
    NicePlot.exportFigToPDF(sprintf('%s.pdf',mosaicFileName), hFig, 300);
    
    % Save mosaic
    mosaicFileName = sprintf('%s.mat',mosaicFileName);
    save(mosaicFileName, 'theMosaic');
    fprintf('Mosaic saved in ''%s''.\n', mosaicFileName);
    
end

function spacing = coneSpacingDistribution(mosaicFOV)
    micronsPerDegree = 300;
    maxEccMicrons = mosaicFOV/2 * micronsPerDegree;
    eccMicrons = 0:5:maxEccMicrons;
    eccMeters = eccMicrons * 1e-6;
    
    spacingQ1 = coneSizeReadData('eccentricity', eccMeters, 'angle', 0*eccMeters)*1e6;
    spacingQ2 = coneSizeReadData('eccentricity', eccMeters, 'angle', 0*eccMeters+90)*1e6;
    spacingQ3 = coneSizeReadData('eccentricity', eccMeters, 'angle', 0*eccMeters+180)*1e6;
    spacingQ4 = coneSizeReadData('eccentricity', eccMeters, 'angle', 0*eccMeters+270)*1e6;
    spacing = (spacingQ1+spacingQ2+spacingQ3+spacingQ4)/4;
end
