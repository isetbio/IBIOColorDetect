function validationData = t_plotDetectThresholdsOnLMPlane(varargin)
% validationData = t_plotDetectThresholdsOnLMPlane(varargin)
%
% Read classification performance data generated by
%   t_colorDetectFindPerformance
%
% A) Plot the psychometric functions with a fit Weibull, which is used to find the threshold in each color direction.
% B) Plot the thresholds in the LM contrast plane.
% C) Fit an ellipse to the thresholds.
%
% This routine is specialized on the assumption that the test directions
% lie in the LM plane.
%
% The fit ellipse may be compared with actual psychophysical data.
%
% Key/value pairs
%   'rParams' - Value the is the rParams structure to use
%   'instanceParams' - Value is the instanceParams structure to use
%   'thresholdParams' - Value is the thresholdParams structure to use
%   'setRngSeed' - true/false (default true).  Set the rng seed to a
%        value so output is reproducible.
%   'generatePlots' - true/false (default true).  Make plots.  This
%        must be true for either plotPsyhometric or plotEllipse to have
%        an effect.
%   'plotPsychometric' - true/false (default true).  Produce
%       psychometric function output graphs.
%   'plotEllipse' - true/false (default true).  Plot a threshold ellipse in
%       LM plane.
%   'delete' - true/false (default false).  Delete the output
%        files.  Not yet implemented.

%% Parse input
p = inputParser;
p.addParameter('rParams',[],@isemptyorstruct);
p.addParameter('instanceParams',[],@isemptyorstruct);
p.addParameter('thresholdParams',[],@isemptyorstruct);
p.addParameter('setRng',true,@islogical);
p.addParameter('generatePlots',true,@islogical);
p.addParameter('plotPsychometric',true,@islogical);
p.addParameter('plotEllipse',true,@islogical);
p.addParameter('delete',false',@islogical);
p.parse(varargin{:});
rParams = p.Results.rParams;
instanceParams = p.Results.instanceParams;
thresholdParams = p.Results.thresholdParams;

%% Clear
if (nargin == 0)
    ieInit; close all;
end

%% Fix random number generator so we can validate output exactly
if (p.Results.setRng)
    rng(1);
end

%% Get the parameters we need
%
% t_colorGaborResponseGenerationParams returns a hierarchical struct of
% parameters used by a number of tutorials and functions in this project.
if (isempty(rParams))
    rParams = responseParamsGenerate;
    
    % Override some defult parameters
    %
    % Set duration equal to sampling interval to do just one frame.
    rParams.temporalParams.simulationTimeStepSecs = 200/1000;
    rParams.temporalParams.stimulusDurationInSeconds = 200/1000;
    rParams.temporalParams.stimulusSamplingIntervalInSeconds = rParams.temporalParams.stimulusDurationInSeconds;
    rParams.temporalParams.secondsToInclude = rParams.temporalParams.stimulusDurationInSeconds;
   
    % No eye movements
    rParams.temporalParams.emPathType = 'none';
    
    rParams.mosaicParams.integrationTimeInSeconds = rParams.temporalParams.stimulusDurationInSeconds;
    rParams.mosaicParams.isomerizationNoise = 'random';         % Type coneMosaic.validNoiseFlags to get valid values
    rParams.mosaicParams.osNoise = 'random';                    % Type outerSegment.validNoiseFlags to get valid values
    rParams.mosaicParams.osModel = 'Linear';
end

%% Parameters that define the LM instances we'll generate here
%
% Make these numbers in the struct small (trialNum = 2, deltaAngle = 180,
% nContrastsPerDirection = 2) to run through a test quickly.
if (isempty(instanceParams))
    instanceParams = instanceParamsGenerate;
end

%% Parameters related to how we find thresholds from responses
if (isempty(thresholdParams))
    thresholdParams = thresholdParamsGenerate;
end

%% Set up the rw object for this program
paramsList = {rParams.spatialParams, rParams.temporalParams, rParams.oiParams, rParams.mosaicParams, rParams.backgroundParams, instanceParams, thresholdParams};
rwObject = IBIOColorDetectReadWriteBasic;
readProgram = 't_colorDetectFindPerformance';
writeProgram = mfilename;

%% Fit the psychometric functions to get thresholds
psychoData = t_fitPsychometricFunctions('rParams',rParams,'instanceParams',instanceParams,'thresholdParams',thresholdParams, ...
    'setRng',p.Results.setRng,'generatePlots',p.Results.generatePlots && p.Results.plotPsychometric,'delete',p.Results.delete);
testContrasts = psychoData.testContrasts;
testConeContrasts = psychoData.testConeContrasts;
thresholdContrasts = psychoData.thresholdContrasts;
thresholdConeContrasts = psychoData.thresholdConeContrasts;

%% Make sure S cone component of test contrasts is 0, because in this
% routine we are assuming that we are just looking in the LM plane.
if (any(testConeContrasts(3,:) ~= 0))
    error('This tutorial only knows about the LM plane');
end

%% Thresholds are generally symmetric around the contrast origin
%
% We'll pad with this assumption, which makes both visualization and
% fitting easier.
thresholdConeContrasts = [thresholdConeContrasts -thresholdConeContrasts];

% Remove any NaN thresholds lurking around, as these will mess up attempts
% to fit.
thresholdConeContrastsForFitting0 = [];
for ii = 1:size(thresholdConeContrasts,2)
    if (~any(isnan(thresholdConeContrasts(:,ii))))
        thresholdConeContrastsForFitting0 = [thresholdConeContrastsForFitting0 thresholdConeContrasts(:,ii)];
    end
end

%% Fit ellipse
%
% This method fits a 3D ellipsoid and extracts the LM plane of
% the fit.
%
% The fit will be very bad off the LM plane, since there are no data there.
% But we don't care, because we are only going to look at the fit in the LM
% plane.  To make the fit stable, we generate data for fitting that are off
% the LM plane by simply producing shrunken and shifted copies of the in
% plane data.  A little klugy.
thresholdConeContrastsForFitting1 = 0.5*thresholdConeContrastsForFitting0;
thresholdConeContrastsForFitting1(3,:) = 0.5;
thresholdConeContrastsForFitting2 = 0.5*thresholdConeContrastsForFitting0;
thresholdConeContrastsForFitting2(3,:) = -0.5;
thresholdContrastsForFitting = [thresholdConeContrastsForFitting0 thresholdConeContrastsForFitting1 thresholdConeContrastsForFitting2];
[fitA,fitAinv,fitQ,fitEllParams] = EllipsoidFit(thresholdContrastsForFitting);

%% Get the LM plane ellipse from the fit
nThetaEllipse = 200;
circleIn2D = UnitCircleGenerate(nThetaEllipse);
circleInLMPlane = [circleIn2D(1,:) ; circleIn2D(2,:) ; zeros(size(circleIn2D(1,:)))];
ellipsoidInLMPlane = PointsOnEllipsoidFind(fitQ,circleInLMPlane);

%% Validation data
if (nargout > 0)
    validationData.testContrasts = testContrasts;
    validationData.testConeContrasts = testConeContrasts;
    validationData.thresholdContrasts = thresholdContrasts;
end

%% Plot the threshold ellipse in the LM contrast plane
if (p.Results.generatePlots && p.Results.plotEllipse)
    contrastLim = 0.02;
    hFig = figure; clf; hold on; set(gca,'FontSize',rParams.plotParams.axisFontSize);
    plot(thresholdConeContrasts(1,:),thresholdConeContrasts(2,:),'ro','MarkerFaceColor','r','MarkerSize',rParams.plotParams.markerSize);
    plot(ellipsoidInLMPlane(1,:),ellipsoidInLMPlane(2,:),'r','LineWidth',2);
    plot([-contrastLim contrastLim],[0 0],'k:','LineWidth',2);
    plot([0 0],[-contrastLim contrastLim],'k:','LineWidth',2);
    xlabel('L contrast','FontSize',rParams.plotParams.labelFontSize); ylabel('M contrast','FontSize',rParams.plotParams.labelFontSize);
    title('M versus L','FontSize',rParams.plotParams.titleFontSize);
    xlim([-contrastLim contrastLim]); ylim([-contrastLim contrastLim]);
    axis('square');
    rwObject.write('LMThresholdContour',hFig,paramsList,writeProgram,'Type','figure');
end



